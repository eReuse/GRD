from django.conf import settings
from django.contrib.gis.db import models as gis_models
from django.contrib.postgres.fields import HStoreField
from django.core.urlresolvers import reverse
from django.db import models
from django.db.models import Q


class Device(models.Model):
    # Device types
    COMPUTER = 'computer'
    MOBILE = 'mobile'
    MONITOR = 'monitor'
    PERIPHERAL = 'peripheral'
    TYPES = (
        (COMPUTER, 'computer'),
        (MOBILE, 'mobile'),
        (MONITOR, 'monitor'),
        (PERIPHERAL, 'peripheral'),
    )
    
    # id is an arbitrary identifier generated by the agent
    id = models.CharField('Identifier provided by the agent.', max_length=128)
    # hardware identifier can be obtained by anyone
    hid = models.CharField('Hardware identifier.', primary_key=True,
                           max_length=128)  # FIXME how long can be hid?
    type = models.CharField(max_length=16, choices=TYPES)
    # XXX is_id_secured & ituuid
    
    def __str__(self):
        return "%s %s" % (self.type, self.pk)
    
    @property
    def components(self):
        try:
            # Get the latest register event (can exist several because
            # of snapshots)
            last_event = self.events.filter(type=Event.REGISTER).latest()
        except Event.DoesNotExist:
            # Device has been registered as component of another Device
            # so it doesn't have a registered event.
            components = []
        else:
            components = list(last_event.components.all())
        
        # Compute add and remove events. Get add and remove together
        # because the order of the operations affects the final result.
        for e in self.events.filter(Q(type=Event.ADD) | Q(type=Event.REMOVE)):
            if e.type == Event.ADD:
                components += e.components.all()
            else:  # Event.REMOVE
                components = list(set(components) - set(e.components.all()))
        
        return components
    
    @property
    def parent(self):
        # Compute events that modify relation between devices.
        RELATION_EVENTS = [Event.REGISTER, Event.ADD, Event.REMOVE]
        try:
            event = self.parent_events.filter(type__in=RELATION_EVENTS).latest()
        except Event.DoesNotExist:
            return None
        
        if event.type == Event.REMOVE:
            return None
        
        return event.device


class EventManager(models.Manager):
    def related_to_device(self, device):
        return self.filter(Q(device=device) | Q(components__in=[device]))


class Event(models.Model):
    # initial events (iteration 1)
    REGISTER = 'register'
    RECYCLE = 'recycle'
    
    # base events (iteration 2)
    USE = 'use'
    TRANSFER = 'transfer'
    COLLECT = 'collect'
    
    # extended events (iteration 3)
    DEREGISTER = 'deregister'
    LOCATE = 'locate'
    ADD = 'add'
    REMOVE = 'remove'
    SNAPSHOT = 'snapshot'
    MIGRATE = 'migrate'
    INCIDENCE = 'incidence'
    
    TYPES = (
        (REGISTER, 'REGISTER'),
        # (USE, 'USE'),
        # (TRANSFER, 'TRANSFER'),
        (COLLECT, 'COLLECT'),
        (RECYCLE, 'RECYCLE'),
        (ADD, 'ADD'),
        (REMOVE, 'REMOVE'),
        (MIGRATE, 'MIGRATE'),
    )
    
    timestamp = models.DateTimeField(auto_now_add=True)
    type = models.CharField(max_length=16, choices=TYPES)
    data = HStoreField(default={})  # A field for storing mappings of strings to strings.
    
    event_time = models.DateTimeField('Time when the event has happened.')
    by_user = models.CharField('User who performs the event.', max_length=32)
    
    agent = models.ForeignKey('Agent', related_name='+')
    device = models.ForeignKey('Device', related_name='events')
    components = models.ManyToManyField('Device', related_name='parent_events')
    
    objects = EventManager()
    
    class Meta:
        get_latest_by = 'timestamp'
        # WARNING: the order of the events affects the computation of
        # the device's state, so be sure that you know what are you
        # doing before changing this field.
        ordering = ['timestamp']
    
    def __str__(self):
        event_date = self.timestamp.strftime("%Y-%m-%d")
        return "%s %s %s" % (self.agent, self.type, event_date)
    
    @property
    def to(self):
        return self.data.get('to', None)


class Agent(models.Model):
    name = models.CharField(max_length=128, unique=True)
    description = models.TextField()
    user = models.OneToOneField(settings.AUTH_USER_MODEL)
    
    def __str__(self):
        return self.name
    
    def get_absolute_url(self):
        return reverse('agent-detail', args=[self.pk])


class Location(gis_models.Model):
    # TODO default spatial reference system for geometry fields is WGS84
    lat = models.FloatField()
    lon = models.FloatField()
    
    event = models.OneToOneField('Event', primary_key=True)
    
    objects = gis_models.GeoManager()
    
    def __str__(self):
        return self.label
